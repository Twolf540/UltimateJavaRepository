## 10.2 - Recursive Searching and Sorting
### 10_2 P1
Binary search v. Linear Search

Linear Search starts at the beginning of the array and moves to the end

Linear searches are iterative and not recursive

Binary searches can be either iterative (example below) or recursive
```java
public static int binarySearch(int [] intArray, int lowPosition, int highPosition, int target){
    int midposition;
    while(lowPosition <= highPosition){
        midPosition = (highPosition + lowPosition) / 2;
        if(intArray[midPosition] < target){
            lowPosition = midPosition + 1;
        }
        else if(intArray[midPosition] > target){
            highPosition = midPosition - 1;
        }
        else{
            return midPosition;
        }
    }
    return -1;
}
```
Binary searches adjust the range that the search looks for the target in based on the element that is located at midPosition.

Binary searches are faster because they do not check every single value. They elimate half of the elements within the range each time they are called.

Recursive Binary Search Example:
```java
public static int binarySearch(int [] intArray, int lowPosition, int highPosition, int target){
    int midPosition = -1;
    if(lowPosition <= highPositon){
        return -1;
    }
    else{
        midposition = (highPosition + lowPosition) / 2;
        if(intArray[midPosition] < target){
            return binarySearch(intArray, (midPositon + 1), highPosition, target);
        }
        else if(intArray[midPosition] > target){
            return binarySearch(intArray, lowPosition, (midPosition - 1), target);
        }
    }
    return midPosition;
}
```
### 10_2 P2
Merge Sort - Sorts the values on the left half and right half of the list seperately and then merges the results together

The rest of the video was just explaining the merge sort. No code.
### 10_2 P3
```java
public void merge(int [] myArray, int low, int high, int middle){
    int [] sortedArray = [high - low];
    for(int x = low; x < high; x++){
        sortedArray[x] = myArray[x];
    }
    if(low < high){
        middle = (low + high) / 2;
        mergeSort(myArray, low, middle);
        mergeSort(myArray, middle + 1, high);
        merge(myArray, low, middle, high);
    }
    int 
}
public void mergeSort(int myArray, int low, int high){
    for(y = 0; y < sortedArray.length - 1; y++){
        for(z = 1; z < sortedArray.length; z++){        
            if(sortedArray[y] > sortedArray[z]){
                int temp = sortedArray[y];
                sortedArray[y] = sortedArray[z];
                sortedArray[z] = temp;
            }
        }
    }
}
public void sortArray(double[] myDucks)
for(int outerLoop = 0; outerLoop < myDucks.length; outerLoop++){
    int minIndex = outerLoop;
    for(int inner = outerLoop + 1; inner < myDucks.length; inner++){
        if(myDucks[inner].compareto(myDucks[minIndex]) < 0){
            minIndex = inner;
        }
    }
    if(minIndex != outerLoop){
        swapItems(minIndex, outerLoop, myDucks);
    }
}
```

